\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ed.info
@documentencoding ISO-8859-15
@settitle GNU @command{ed} Manual
@finalout
@c %**end of header

@set UPDATED 6 January 2021
@set VERSION 1.17

@dircategory Basics
@direntry
* Ed: (ed).                     The GNU line editor
@end direntry

@copying
Copyright @copyright{} 1993, 1994, 2006-2021 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end copying

@ifnothtml
@titlepage
@title GNU ed
@subtitle The GNU line editor
@subtitle for GNU ed version @value{VERSION}, @value{UPDATED}
@author by Andrew L. Moore, François Pinard, and Antonio Diaz Diaz

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents
@end ifnothtml

@ifnottex
@node Top
@top The GNU ed line editor

This manual is for GNU ed (version @value{VERSION}, @value{UPDATED}).

@menu
* Overview::                        Overview of the @command{ed} command
* Introduction to line editing::    Getting started with GNU @command{ed}
* Invoking ed::                     Command line interface
* Line addressing::                 Specifying lines/ranges in the buffer
* Regular expressions::             Patterns for selecting text
* Commands::                        Commands recognized by GNU @command{ed}
* Limitations::                     Intrinsic limits of GNU @command{ed}
* Diagnostics::                     GNU @command{ed} error handling
* Problems::                        Reporting bugs
* GNU Free Documentation License::  How you can copy and share this manual
@end menu

@sp 1
@insertcopying
@end ifnottex


@node Overview
@chapter Overview

@uref{http://www.gnu.org/software/ed/ed.html,,GNU ed}
is a line-oriented text editor. It is used to create, display, modify
and otherwise manipulate text files, both interactively and via shell
scripts. A restricted version of ed, red, can only edit files in the current
directory and cannot execute shell commands. Ed is the 'standard' text
editor in the sense that it is the original editor for Unix, and thus widely
available. For most purposes, however, it is superseded by full-screen
editors such as GNU Emacs or GNU Moe.

GNU ed is based on the editor algorithm described in Brian W. Kernighan and
P. J. Plauger's book "Software Tools in Pascal", Addison-Wesley, 1981.

If invoked with a @var{file} argument, then a copy of @var{file} is read
into the editor's buffer. Changes are made to this copy and not directly
to @var{file} itself. Upon quitting @command{ed}, any changes not
explicitly saved with a @samp{w} command are lost.

Editing is done in two distinct modes: @dfn{command} and @dfn{input}.
When first invoked, @command{ed} is in command mode. In this mode
commands are read from the standard input and executed to manipulate the
contents of the editor buffer. A typical command might look like:

@example
,s/@var{old}/@var{new}/g
@end example

which replaces all occurences of the string @var{old} with @var{new}.

When an input command, such as @samp{a} (append), @samp{i} (insert) or
@samp{c} (change), is given, @command{ed} enters input mode. This is the
primary means of adding text to a file. In this mode, no commands are
available; instead, the standard input is written directly to the editor
buffer. A @dfn{line} consists of the text up to and including a
@key{newline} character. Input mode is terminated by entering a single
period (@samp{.}) on a line.

All @command{ed} commands operate on whole lines or ranges of lines;
e.g., the @samp{d} command deletes lines; the @samp{m} command moves
lines, and so on. It is possible to modify only a portion of a line by
means of replacement, as in the example above. However even here, the
@samp{s} command is applied to whole lines at a time.

In general, @command{ed} commands consist of zero or more line
addresses, followed by a single character command and possibly
additional parameters; i.e., commands have the structure:

@example
[@var{address}[,@var{address}]]@var{command}[@var{parameters}]
@end example

The @var{address}es indicate the line or range of lines to be affected
by the command. If fewer addresses are given than the command accepts,
then default addresses are supplied.


@node Introduction to line editing
@chapter Introduction to line editing

@command{ed} was created, along with the Unix operating system, by Ken
Thompson and Dennis Ritchie. It is the refinement of its more complex,
programmable predecessor, @cite{QED}, to which Thompson and Ritchie had
already added pattern matching capabilities (@pxref{Regular
expressions}).

For the purposes of this tutorial, a working knowledge of the Unix shell
@command{sh} and the Unix file system is recommended, since @command{ed}
is designed to interact closely with them.
@ifnothtml
(@xref{Top,GNU bash manual,,bash},
@end ifnothtml
@ifhtml
(See the
@uref{http://www.gnu.org/software/bash/manual/,,bash manual}
@end ifhtml
for details about bash).

The principal difference between line editors and display editors is
that display editors provide instant feedback to user commands, whereas
line editors require sometimes lengthy input before any effects are
seen. The advantage of instant feedback, of course, is that if a mistake
is made, it can be corrected immediately, before more damage is done.
Editing in @command{ed} requires more strategy and forethought; but if
you are up to the task, it can be quite efficient.

Much of the @command{ed} command syntax is shared with other Unix utilities.

As with the shell, @key{RETURN} (the carriage-return key) enters a line
of input. So when we speak of "entering" a command or some text in
@command{ed}, @key{RETURN} is implied at the end of each line. Prior to
typing @key{RETURN}, corrections to the line may be made by typing
either @key{BACKSPACE} to erase characters backwards, or @key{CONTROL}-u
(i.e., hold the CONTROL key and type u) to erase the whole line.

When @command{ed} first opens, it expects to be told what to do but
doesn't prompt us like the shell. So let's begin by telling @command{ed}
to do so with the @key{P} (@dfn{prompt}) command:

@example
$ ed
P
*
@end example

By default, @command{ed} uses asterisk (@samp{*}) as command prompt to
avoid confusion with the shell command prompt (@samp{$}).

We can run Unix shell (@command{sh}) commands from inside @command{ed}
by prefixing them with @key{!} (exclamation mark, aka "bang"). For
example:

@example
*!date
Mon Jun 26 10:08:41 PDT 2006
!
*!for s in hello world; do echo $s; done
hello
world
!
*
@end example

So far, this is no different from running commands in the Unix shell.
But let's say we want to edit the output of a command, or save it to a
file. First we must capture the command output to a temporary location
called a @dfn{buffer} where @command{ed} can access it. This is done
with @command{ed}'s @key{r} command (mnemonic: @dfn{read}):

@example
*r !cal -m
137
*
@end example

Here @command{ed} is telling us that it has just read 137 characters
into the editor buffer - i.e., the output of the @command{cal} command,
which prints a simple ASCII calendar. To display the buffer contents we
issue the @key{p} (@dfn{print}) command (not to be confused with the
prompt command, which is uppercase!). To indicate the range of lines in
the buffer that should be printed, we prefix the command with @key{,}
(comma) which is shorthand for "the whole buffer":

@example
*,p
      June 2006
Mo Tu We Th Fr Sa Su
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30

*
@end example

Now let's write the buffer contents to a file named @samp{junk} with the
@key{w} (@dfn{write}) command:

@example
*w junk
137
*
@end example

Need we say? It's good practice to frequently write the buffer contents,
since unwritten changes to the buffer will be lost when we exit
@command{ed}.

The sample sessions below illustrate some basic concepts of line editing
with @command{ed}. We begin by creating a file, @samp{sonnet}, with some
help from Shakespeare. As with the shell, all input to @command{ed} must
be followed by a @key{newline} character. Commands beginning with
@samp{#} are taken as comments and ignored. Input mode lines that begin
with @samp{#} are just more input.

@example
$ ed
# The 'a' command is for appending text to the editor buffer.
a
No more be grieved at that which thou hast done.
Roses have thorns, and filvers foutians mud.
Clouds and eclipses stain both moon and sun,
And loathsome canker lives in sweetest bud.
.
# Entering a single period on a line returns @command{ed} to command mode.
# Now write the buffer to the file @samp{sonnet} and quit:
w sonnet
183
# @command{ed} reports the number of characters written.
q
$ ls -l
total 2
-rw-rw-r--    1 alm           183 Nov 10 01:16 sonnet
$
@end example

In the next example, some typos are corrected in the file @samp{sonnet}.

@example
$ ed sonnet
183
# Begin by printing the buffer to the terminal with the @samp{p} command.
# The ',' means "all lines".
,p
No more be grieved at that which thou hast done.
Roses have thorns, and filvers foutians mud.
Clouds and eclipses stain both moon and sun,
And loathsome canker lives in sweetest bud.
# Select line 2 for editing.
2
Roses have thorns, and filvers foutians mud.
# Use the substitute command, @samp{s}, to replace 'filvers' with 'silver',
# and print the result.
s/filvers/silver/p
Roses have thorns, and silver foutians mud.
# And correct the spelling of 'fountains'.
s/utia/untai/p
Roses have thorns, and silver fountains mud.
w sonnet
183
q
$
@end example

Since @command{ed} is line-oriented, we have to tell it which line, or
range of lines we want to edit. In the example above, we do this by
specifying the line's number, or sequence in the buffer. Alternatively,
we could have specified a unique string in the line, e.g.,
@samp{/filvers/}, where the @samp{/}s delimit the string in question.
Subsequent commands affect only the selected line, a.k.a. the
@dfn{current} line. Portions of that line are then replaced with the
substitute command, whose syntax is @samp{s/@var{old}/@var{new}/}.

Although @command{ed} accepts only one command per line, the print command
@samp{p} is an exception, and may be appended to the end of most commands.

In the next example, a title is added to our sonnet.

@example
$ ed sonnet
183
a
 Sonnet #50
.
,p
No more be grieved at that which thou hast done.
Roses have thorns, and silver fountains mud.
Clouds and eclipses stain both moon and sun,
And loathsome canker lives in sweetest bud.
 Sonnet #50
# The title got appended to the end; we should have used '0a'
# to append "before the first line".
# Move the title to its proper place.
5m0p
 Sonnet #50
# The title is now the first line, and the current address has been
# set to the address of this line as well.
,p
 Sonnet #50
No more be grieved at that which thou hast done.
Roses have thorns, and silver fountains mud.
Clouds and eclipses stain both moon and sun,
And loathsome canker lives in sweetest bud.
wq sonnet
195
$
@end example

When @command{ed} opens a file, the current address is initially set to
the address of the last line of that file. Similarly, the move command
@samp{m} sets the current address to the address of the last line moved.

Related programs or routines are @command{vi (1)}, @command{sed (1)},
@command{regex (3)}, @command{sh (1)}. Relevant documents are:

@quotation
Unix User's Manual Supplementary Documents: 12 --- 13
@end quotation

@quotation
B. W. Kernighan and P. J. Plauger: "Software Tools in Pascal",
Addison-Wesley, 1981.
@end quotation


@node Invoking ed
@chapter Invoking ed

The format for running @command{ed} is:

@example
ed [@var{options}] [@var{file}]
red [@var{options}] [@var{file}]
@end example

@var{file} specifies the name of a file to read. If @var{file} is
prefixed with a bang (!), then it is interpreted as a shell command. In
this case, what is read is the standard output of @var{file} executed
via @command{sh (1)}. To read a file whose name begins with a bang,
prefix the name with a backslash (@kbd{\}). The default filename is set
to @var{file} only if it is not prefixed with a bang.

@command{ed} supports the following
@uref{http://www.nongnu.org/arg-parser/manual/arg_parser_manual.html#Argument-syntax,,options}:
@ifnothtml
@xref{Argument syntax,,,arg_parser}.
@end ifnothtml

@table @code
@item -h
@itemx --help
Print an informative help message describing the options and exit.

@item -V
@itemx --version
Print the version number of @command{ed} on the standard output and exit.
This version number should be included in all bug reports.

@item -E
@itemx --extended-regexp
Use extended regular expressions instead of the basic regular expressions
mandated by POSIX.

@item -G
@itemx --traditional
Forces backwards compatibility. This affects the behavior of the
@command{ed} commands @samp{G}, @samp{V}, @samp{f}, @samp{l}, @samp{m},
@samp{t} and @samp{!!}. If the default behavior of these commands does
not seem familiar, then try invoking @command{ed} with this switch.

@item -l
@itemx --loose-exit-status
Don't exit with bad status if a command happens to "fail" (for example
if a substitution command finds nothing to replace). This can be useful
when @command{ed} is invoked as the editor for crontab.

@item -p @var{string}
@itemx --prompt=@var{string}
Specifies a command prompt string and turns prompting on. Showing the prompt
string may be toggled on and off with the @samp{P} command.

@item -r
@itemx --restricted
Run in restricted mode. This mode disables editing of files out of the
current directory and execution of shell commands.

@item -s
@itemx --quiet
@itemx --silent
Suppresses diagnostics, the printing of byte counts by @samp{e},
@samp{E}, @samp{r} and @samp{w} commands, and the @samp{!} prompt after
a @samp{!} command. This option may be useful if @command{ed}'s standard
input is from a script.

@item -v
@itemx --verbose
Verbose mode; prints error explanations. This may be toggled on and off
with the @samp{H} command.

@end table

Exit status: 0 if no errors occurred; otherwise >0.


@node Line addressing
@chapter Line addressing

An address represents the number of a line in the buffer. @command{ed}
maintains a @dfn{current address} which is typically supplied to
commands as the default address when none is specified. When a file is
first read, the current address is set to the address of the last line
of the file. In general, the current address is set to the address of
the last line affected by a command.

One exception to the rule that addresses represent line numbers is the
address @samp{0} (zero). This means "at the beginning of the buffer",
and is valid wherever it makes sense.

An address range is two addresses separated either by a comma (@samp{,}) or
a semicolon (@samp{;}). In a semicolon-delimited range, the current address
(@samp{.}) is set to the first address before the second address is
calculated. This feature can be used to set the starting line for searches
if the second address contains a regular expression. The value of the first
address in a range cannot exceed the value of the second.

Addresses can be omitted on either side of the comma or semicolon
separator. If only the first address is given in a range, then the
second address is set to the given address. If only the second address
is given, the resulting address pairs are @samp{1,addr} and
@samp{.;addr} respectively. If a @var{n}-tuple of addresses is given
where @var{n} > 2, then the corresponding range is determined by the
last two addresses in the @var{n}-tuple. If only one address is
expected, then the last address is used. It is an error to give any
number of addresses to a command that requires zero addresses.

A line address is constructed as follows:

@table @code
@item .
The current line (address) in the buffer.

@item $
The last line in the buffer.

@item @var{n}
The @var{n}th line in the buffer, where @var{n} is a number in the range
@samp{0,$}.

@item +@var{n}
The @var{n}th next line, where @var{n} is a non-negative number.

@item -@var{n}
The @var{n}th previous line, where @var{n} is a non-negative number.

@item +
The next line. This is equivalent to @samp{+1} and may be repeated with
cumulative effect.

@item -
The previous line. This is equivalent to @samp{-1} and may be repeated
with cumulative effect.

@item ,
The first through last lines in the buffer. This is equivalent to the
address range @samp{1,$}.

@item ;
The current through last lines in the buffer. This is equivalent to the
address range @samp{.;$}.

@item /@var{re}/
The next line containing the regular expression @var{re}. The search
wraps to the beginning of the buffer and continues down to the current
line, if necessary.

@item ?@var{re}?
The previous line containing the regular expression @var{re}. The search
wraps to the end of the buffer and continues up to the current line, if
necessary.

@item 'x
The apostrophe-x character pair addresses the line previously marked by
a @samp{k} (mark) command, where @samp{x} is a lower case letter from
the portable character set @samp{[a-z]}.

@end table

Addresses can be followed by one or more address offsets, optionally
separated by whitespace. Offsets are constructed as follows:

@itemize @bullet
@item
@samp{+} or @samp{-} followed by a number adds or subtracts the indicated
number of lines to or from the address.

@item
@samp{+} or @samp{-} not followed by a number adds or subtracts 1 to or
from the address.

@item
A number adds the indicated number of lines to the address.

@end itemize

It is not an error if an intermediate address value is negative or
greater than the address of the last line in the buffer. It is an error
if the final address value is negative or greater than the address of
the last line in the buffer. It is an error if a search for a @var{re}
fails to find a matching line.


@node Regular expressions
@chapter Regular expressions

Regular expressions are patterns used in selecting text. For example,
the @command{ed} command

@example
g/@var{string}/
@end example

@noindent
prints all lines containing @var{string}. Regular expressions are also
used by the @samp{s} command for selecting old text to be replaced with
new text.

In addition to specifying string literals, regular expressions can
represent classes of strings. Strings thus represented are said to be
matched by the corresponding regular expression. If it is possible for a
regular expression to match several strings in a line, then the
left-most match is the one selected. If the regular expression permits a
variable number of matching characters, the longest sequence starting at
that point is matched.

A null @var{re} is equivalent to the last @var{re} encountered.

The following symbols are used in constructing regular expressions
using POSIX basic regular expression syntax:

@table @code

@item @var{c}
Any character @var{c} not listed below, including @samp{@{}, @samp{@}},
@samp{(}, @samp{)}, @samp{<} and @samp{>}, matches itself.

@item \@var{c}
Any backslash-escaped character @var{c}, other than @samp{@{},
@samp{@}}, @samp{(}, @samp{)}, @samp{<}, @samp{>}, @samp{b}, @samp{B},
@samp{w}, @samp{W}, @samp{+} and @samp{?}, matches itself.

@item .
Matches any single character.

@item [@var{char-class}]
Matches any single character in @var{char-class}. To include a @samp{]}
in @var{char-class}, it must be the first character. A range of
characters may be specified by separating the end characters of the
range with a @samp{-}, e.g., @samp{a-z} specifies the lower case
characters. The following literal expressions can also be used in
@var{char-class} to specify sets of characters:

@example
[:alnum:] [:cntrl:] [:lower:] [:space:]
[:alpha:] [:digit:] [:print:] [:upper:]
[:blank:] [:graph:] [:punct:] [:xdigit:]
@end example

If @samp{-} appears as the first or last character of @var{char-class},
then it matches itself. All other characters in @var{char-class} match
themselves.

Patterns in @var{char-class} of the form:
@example
[.@var{col-elm}.]
[=@var{col-elm}=]
@end example

@noindent
where @var{col-elm} is a @dfn{collating element} are interpreted according
to @samp{locale (5)}. See @samp{regex (7)} for an explanation of these
constructs.

@item [^@var{char-class}]
Matches any single character, other than newline, not in @var{char-class}.
@var{char-class} is defined as above.

@item ^
If @samp{^} is the first character of a regular expression, then it
anchors the regular expression to the beginning of a line. Otherwise,
it matches itself.

@item $
If @samp{$} is the last character of a regular expression, it anchors the
regular expression to the end of a line. Otherwise, it matches itself.

@item \(@var{re}\)
Defines a (possibly null) subexpression @var{re}. Subexpressions may be
nested. A subsequent backreference of the form @samp{\@var{n}}, where
@var{n} is a number in the range [1,9], expands to the text matched by
the @var{n}th subexpression. For example, the regular expression
@samp{\(a.c\)\1} matches the string @samp{abcabc}, but not @samp{abcadc}.
Subexpressions are ordered relative to their left delimiter.

@item *
Matches zero or more repetitions of the regular expression immediately
preceding it. The regular expression can be either a single character
regular expression or a subexpression. If @samp{*} is the first
character of a regular expression or subexpression, then it matches
itself. The @samp{*} operator sometimes yields unexpected results. For
example, the regular expression @samp{b*} matches the beginning of the
string @samp{abbb}, as opposed to the substring @samp{bbb}, since a null
match is the only left-most match.

@item \@{@var{n},@var{m}\@}
@itemx \@{@var{n},\@}
@itemx \@{@var{n}\@}
Matches the single character regular expression or subexpression
immediately preceding it at least @var{n} and at most @var{m} times. If
@var{m} is omitted, then it matches at least @var{n} times. If the comma
is also omitted, then it matches exactly @var{n} times. If any of these
forms occurs first in a regular expression or subexpression, then it is
interpreted literally (i.e., the regular expression @samp{\@{2\@}}
matches the string @samp{@{2@}}, and so on).

@end table

The following extensions to basic regular expression operators are preceded
by a backslash @samp{\} to distinguish them from traditional @command{ed}
syntax. They may be unavailable depending on the particular regex
implementation in your system.

@table @code

@item \<
@itemx \>
Anchors the single character regular expression or subexpression
immediately following it to the beginning (in the case of @samp{\<}) or
ending (in the case of @samp{\>}) of a @dfn{word}, i.e., in ASCII, a
maximal string of alphanumeric characters, including the underscore (_).

@item  \`
@itemx \'
Unconditionally matches the beginning @samp{\`} or ending @samp{\'} of a line.

@item \?
Optionally matches the single character regular expression or
subexpression immediately preceding it. For example, the regular
expression @samp{a[bd]\?c} matches the strings @samp{abc}, @samp{adc}
and @samp{ac}. If @samp{\?} occurs at the beginning of a regular
expressions or subexpression, then it matches a literal @samp{?}.

@item \+
Matches the single character regular expression or subexpression
immediately preceding it one or more times. So the regular expression
@samp{a\+} is shorthand for @samp{aa*}. If @samp{\+} occurs at the
beginning of a regular expression or subexpression, then it matches a
literal @samp{+}.

@item \b
Matches the beginning or ending (null string) of a word. Thus the
regular expression @samp{\bhello\b} is equivalent to @samp{\<hello\>}.
However, @samp{\b\b} is a valid regular expression whereas @samp{\<\>}
is not.

@item \B
Matches (a null string) inside a word.

@item \w
Matches any character in a word.

@item \W
Matches any character not in a word.

@end table


@node Commands
@chapter Commands

All @command{ed} commands are single characters, though some require
additonal parameters. If a command's parameters extend over several
lines, then each line except for the last must be terminated with a
backslash (@samp{\}).

In general, at most one command is allowed per line. However, most
commands accept a print suffix, which is any of @samp{p} (print),
@samp{l} (list), or @samp{n} (enumerate), to print the last line
affected by the command. It is not portable to give more than one print
suffix, but @command{ed} allows any combination of non-repeated print
suffixes and combines their effects. If any suffix letter is given, it
must immediately follow the command.

The @samp{e}, @samp{E}, @samp{f}, @samp{r}, and @samp{w} commands take an
optional @var{file} parameter, separated from the command letter by one or
more whitespace characters.

An interrupt (typically @key{Control-C}) has the effect of aborting the
current command and returning the editor to command mode.

@command{ed} recognizes the following commands. The commands are shown
together with the default address or address range supplied if none is
specified (in parenthesis).

@table @code

@item (.)a
Appends text to the buffer after the addressed line. The address
@samp{0} (zero) is valid for this command; it places the entered text at
the beginning of the buffer. Text is entered in input mode. The current
address is set to the address of the last line entered or, if there were
none, to the addressed line.

@item (.,.)c
Changes lines in the buffer. The addressed lines are deleted from the
buffer, and text is inserted in their place. Text is entered in input mode.
The current address is set to the address of the last line entered or, if
there were none, to the new address of the line after the last line deleted;
if the lines deleted were originally at the end of the buffer, the current
address is set to the address of the new last line; if no lines remain in
the buffer, the current address is set to zero. The lines deleted are copied
to the cut buffer.

@item (.,.)d
Deletes the addressed lines from the buffer. The current address is set to
the new address of the line after the last line deleted; if the lines
deleted were originally at the end of the buffer, the current address is set
to the address of the new last line; if no lines remain in the buffer, the
current address is set to zero. The lines deleted are copied to the cut
buffer.

@item e @var{file}
Edits @var{file}, and sets the default filename. If @var{file} is not
specified, then the default filename is used. Any lines in the buffer
are deleted before the new file is read. The current address is set to
the address of the last line in the buffer.

If @var{file} is prefixed with a bang (!), then it is interpreted as a
shell command whose output is to be read, (@pxref{shell escape command}
@samp{!} below). In this case the default filename is unchanged.

A warning is printed if any changes have been made in the buffer since
the last @samp{w} command that wrote the entire buffer to a file.

@item E @var{file}
Edits @var{file} unconditionally. This is similar to the @samp{e}
command, except that unwritten changes are discarded without warning.

@item f @var{file}
Sets the default filename to @var{file}. If @var{file} is not specified,
then the default unescaped filename is printed.

@item (1,$)g/@var{re}/@var{command-list}
Global command. The global command makes two passes over the file. On the
first pass, all the addressed lines matching a regular expression @var{re}
are marked. Then, going sequentially from the beginning of the file to the
end of the file, the given @var{command-list} is executed for each marked
line, with the current address set to the address of that line. Any line
modified by the @var{command-list} is unmarked. The final value of the
current address is the value assigned by the last command in the last
@var{command-list} executed. If there were no matching lines, the current
address is unchanged. The execution of @var{command-list} stops on the first
error.

The first command of @var{command-list} must appear on the same line as the
@samp{g} command. The other commands of @var{command-list} must appear on
separate lines. All lines of a multi-line @var{command-list} except the last
line must be terminated with a backslash (@samp{\}). Any commands are
allowed, except for @samp{g}, @samp{G}, @samp{v}, and @samp{V}. The @samp{.}
terminating the input mode of commands @samp{a}, @samp{c}, and @samp{i} can
be omitted if it would be the last line of @var{command-list}. By default, a
newline alone in @var{command-list} is equivalent to a @samp{p} command. If
@command{ed} is invoked with the command-line option @samp{-G}, then a
newline in @var{command-list} is equivalent to a @samp{.+1p} command.

@item (1,$)G/@var{re}/
Interactive global command. Interactively edits the addressed lines
matching a regular expression @var{re}. For each matching line, the line
is printed, the current address is set, and the user is prompted to
enter a @var{command-list}. The final value of the current address is
the value assigned by the last command executed. If there were no
matching lines, the current address is unchanged.

The format of @var{command-list} is the same as that of the @samp{g}
command. A newline alone acts as a null command list. A single @samp{&}
repeats the last non-null command list.

@item h
Help. Prints an explanation of the last error.

@item H
Toggles the printing of error explanations. By default, explanations are
not printed. It is recommended that ed scripts begin with this command
to aid in debugging.

@item (.)i
Inserts text in the buffer before the addressed line. The address
@samp{0} (zero) is valid for this command; it places the entered text at
the beginning of the buffer. Text is entered in input mode. The current
address is set to the address of the last line entered or, if there were
none, to the addressed line.

@item (.,.+1)j
Joins the addressed lines, replacing them by a single line containing their
joined text. If only one address is given, this command does nothing. If
lines are joined, the lines replaced are copied to the cut buffer and the
current address is set to the address of the joined line. Else, the current
address is unchanged.

@item (.)kx
Marks a line with a lower case letter @samp{x}. The line can then be
addressed as @samp{'x} (i.e., a single quote followed by @samp{x}) in
subsequent commands. The mark is not cleared until the line is deleted
or otherwise modified. The current address is unchanged.

@item (.,.)l
List command. Prints the addressed lines unambiguously. The end of each
line is marked with a @samp{$}, and every @samp{$} character within the
text is printed with a preceding backslash. Special characters are
printed as escape sequences. The current address is set to the address
of the last line printed.

@item (.,.)m(.)
Moves lines in the buffer. The addressed lines are moved to after the
right-hand destination address. The destination address @samp{0} (zero)
is valid for this command; it moves the addressed lines to the beginning
of the buffer. It is an error if the destination address falls within
the range of lines to be moved. The current address is set to the new
address of the last line moved.

@item (.,.)n
Number command. Prints the addressed lines, preceding each line by its
line number and a @key{tab}. The current address is set to the address
of the last line printed.

@item (.,.)p
Prints the addressed lines. The current address is set to the address of
the last line printed.

@item P
Toggles the command prompt on and off. Unless a prompt string is specified
with the command-line option @samp{-p}, the command prompt is by default
turned off. The default prompt string is an asterisk (@samp{*}).

@item q
Quits @command{ed}. A warning is printed if any changes have been made
in the buffer since the last @samp{w} command that wrote the entire
buffer to a file.

@item Q
Quits @command{ed} unconditionally. This is similar to the @samp{q}
command, except that unwritten changes are discarded without warning.

@item ($)r @var{file}
Reads @var{file} and appends it after the addressed line. If @var{file}
is not specified, then the default filename is used. If there is no
default filename prior to the command, then the default filename is set
to @var{file}. Otherwise, the default filename is unchanged. The address
@samp{0} (zero) is valid for this command; it reads the file at the
beginning of the buffer. The current address is set to the address of
the last line read or, if there were none, to the addressed line.

If @var{file} is prefixed with a bang (!), then it is interpreted as a
shell command whose output is to be read, (@pxref{shell escape command}
@samp{!} below). In this case the default filename is unchanged.

@item (.,.)s/@var{re}/@var{replacement}/
Substitute command. Replaces text in the addressed lines matching a regular
expression @var{re} with @var{replacement}. By default, only the first match
in each line is replaced. The @samp{s} command accepts any combination of
the suffixes @samp{g}, @samp{@var{count}}, @samp{l}, @samp{n}, and @samp{p}.
If the @samp{g} (global) suffix is given, then every match is replaced. The
@samp{@var{count}} suffix, where @var{count} is a positive number, causes
only the @var{count}th match to be replaced. @samp{g} and @samp{@var{count}}
can't be specified in the same command. @samp{l}, @samp{n}, and @samp{p} are
the usual print suffixes. It is an error if no substitutions are performed
on any of the addressed lines. The current address is set to the address of
the last line on which a substitution occurred. If a line is split, a
substitution is considered to have occurred on each of the new lines. If no
substitution is performed, the current address is unchanged. The last line
modified is copied to the cut buffer.

@var{re} and @var{replacement} may be delimited by any character other
than @key{space}, @key{newline} and the characters used by the form of
the @samp{s} command shown below. If the last delimiter is omitted, then
the last line affected is printed as if the print suffix @samp{p} were
specified. The last delimiter can't be omitted if the @samp{s} command
is part of a @samp{g} or @samp{v} @var{command-list} and is not the last
command in the list, because the meaning of the following escaped
newline would become ambiguous.

An unescaped @samp{&} in @var{replacement} is replaced by the currently
matched text. The character sequence @samp{\@var{m}} where @var{m} is a
number in the range [1,9], is replaced by the @var{m}th backreference
expression of the matched text. If the corresponding backreference
expression does not match, then the character sequence @samp{\@var{m}} is
replaced by the empty string. If @var{replacement} consists of a single
@samp{%}, then @var{replacement} from the last substitution is used.

A line can be split by including a newline escaped with a backslash
(@samp{\}) in @var{replacement}. Each backslash in @var{replacement}
removes the special meaning (if any) of the following character.

@item (.,.)s
Repeats the last substitution. This form of the @samp{s} command accepts
the @samp{g} and @samp{@var{count}} suffixes described above, and any
combination of the suffixes @samp{p} and @samp{r}. The @samp{g} suffix
toggles the global suffix of the last substitution and resets
@var{count} to 1. The @samp{p} suffix toggles the print suffixes of the
last substitution. The @samp{r} suffix causes the @var{re} of the last
search to be used instead of the @var{re} of the last substitution (if
the search happened after the substitution).

@item (.,.)t(.)
Copies (i.e., transfers) the addressed lines to after the right-hand
destination address. If the destination address is @samp{0} (zero), the
lines are copied at the beginning of the buffer. The current address is
set to the address of the last line copied.

@item u
Undoes the effect of the last command that modified anything in the buffer
and restores the current address to what it was before the command. The
global commands @samp{g}, @samp{G}, @samp{v}, and @samp{V} are treated as a
single command by undo. @samp{u} is its own inverse; it can undo only the
last command.

@item (1,$)v/@var{re}/@var{command-list}
This is similar to the @samp{g} command except that it applies
@var{command-list} to each of the addressed lines not matching the
regular expression @var{re}.

@item (1,$)V/@var{re}/
This is similar to the @samp{G} command except that it interactively
edits the addressed lines not matching the regular expression @var{re}.

@item (1,$)w @var{file}
Writes the addressed lines to @var{file}. Any previous contents of
@var{file} are lost without warning. If there is no default filename,
then the default filename is set to @var{file}, otherwise it is
unchanged. If no filename is specified, then the default filename is
used. The current address is unchanged.

If @var{file} is prefixed with a bang (!), then it is interpreted as a
shell command and the addressed lines are written to its standard input,
(@pxref{shell escape command} @samp{!} below). In this case the default
filename is unchanged. Writing the buffer to a shell command does not
prevent the warning to the user if an attempt is made to overwrite or
discard the buffer via the @samp{e} or @samp{q} commands.

@item (1,$)wq @var{file}
Writes the addressed lines to @var{file}, and then executes a @samp{q}
command.

@item (1,$)W @var{file}
Appends the addressed lines to the end of @var{file}. This is similar to the
@samp{w} command, except that the previous contents of @var{file} are not
clobbered. The current address is unchanged.

@item (.)x
Copies (puts) the contents of the cut buffer to after the addressed
line. The current address is set to the address of the last line copied.

@item (.,.)y
Copies (yanks) the addressed lines to the cut buffer. The cut buffer is
overwritten by subsequent @samp{c}, @samp{d}, @samp{j}, @samp{s}, or
@samp{y} commands. The current address is unchanged.

@item (.+1)z@var{n}
Scroll. Prints @var{n} lines at a time starting at addressed line, and sets
window size to @var{n}. If @var{n} is not specified, then the current window
size is used. Window size defaults to screen size minus two lines, or to 22
if screen size can't be determined. The current address is set to the
address of the last line printed.

@anchor{shell escape command}
@item !@var{command}
Shell escape command. Executes @var{command} via @command{sh (1)}. If
the first character of @var{command} is @samp{!}, then it is replaced by
the text of the previous @samp{!@var{command}}. Thus, @samp{!!} repeats
the previous @samp{!@var{command}}. @command{ed} does not process
@var{command} for backslash (@samp{\}) escapes. However, an unescaped
@samp{%} is replaced by the default filename. When the shell returns
from execution, a @samp{!} is printed to the standard output. The
current address is unchanged.

@item (.,.)#
Begins a comment; the rest of the line, up to a newline, is ignored. If a
line address followed by a semicolon is given, then the current address is
set to that address. Otherwise, the current address is unchanged.

@item ($)=
Prints the line number of the addressed line. The current address is
unchanged.

@item (.+1)@key{newline}
Null command. An address alone prints the addressed line. A
@key{newline} alone is equivalent to @samp{+1p}. The current address is
set to the address of the printed line.

@end table


@node Limitations
@chapter Limitations

If the terminal hangs up, @command{ed} attempts to write the buffer to
the file @file{ed.hup} or, if this fails, to @file{$HOME/ed.hup}.

@command{ed} processes @var{file} arguments for backslash escapes, i.e., in
a filename, any character preceded by a backslash (@samp{\}) is interpreted
literally. For example, @w{@samp{ed 'hello\tworld'}} will edit the file
@samp{hellotworld}.

If a text (non-binary) file is not terminated by a newline character, then
@command{ed} appends one on reading/writing it. In the case of a binary
file, @command{ed} does not append a newline on reading/writing. A binary
file is one containing at least one ASCII NUL character. If the last line
has been modified, reading an empty file, for example /dev/null, prior to
writing prevents appending a newline to a binary file.

In order to keep track of the text lines in the buffer, @command{ed} uses a
doubly linked list of structures containing the position and size of each
line. This results in a per line overhead of 2 @samp{pointer}s, 1 @samp{long
int}, and 1 @samp{int}.


@node Diagnostics
@chapter Diagnostics

When an error occurs, if @command{ed}'s input is from a regular file or
here document, then it exits, otherwise it prints a @samp{?} and returns
to command mode. An explanation of the last error can be printed with
the @samp{h} (help) command.

If the @samp{u} (undo) command occurs in a global command list, then the
command list is executed only once.

Attempting to quit @command{ed} or edit another file before writing a
modified buffer results in an error. If the command is entered a second
time, it succeeds, but any changes to the buffer are lost.


@node Problems
@chapter Reporting bugs

There are probably bugs in @command{ed}. There are certainly errors and
omissions in this manual. If you report them, they will get fixed. If
you don't, no one will ever know about them and they will remain unfixed
for all eternity, if not longer.

If you find a bug in @command{ed}, please send electronic mail to
@email{bug-ed@@gnu.org}. Include the version number, which you can
find by running @w{@samp{ed --version}}.


@node GNU Free Documentation License
@chapter GNU Free Documentation License
@include fdl.texi

@bye
